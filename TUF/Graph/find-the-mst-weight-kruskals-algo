## https://takeuforward.org/plus/dsa/graph/minimum-spanning-tree/find-the-mst-weight

class Solution {
    static class DisjointSet{
        int[] rank;
        int[] par;
        
        int[] size;

        public DisjointSet(int n) {
            rank = new int[n];
            par = new int[n];
            size = new int[n];


            for(int ind=0;ind<n;ind++){
                par[ind]=ind;
            }

            Arrays.fill(size,1);
        
        }


        public boolean find(int u, int v) {

            return findUPar(u) == findUPar(v);

        }

        int findUPar(int u){
            
            if(par[u] == u){
                return u;
            }

            int res = findUPar(par[u]);
            par[u] = res;
            return res;
        }

        public void unionByRank(int u, int v) {
            
        int pu = findUPar(u);
        int pv = findUPar(v);

        if(pu == pv){
            return;
        }

        if(rank[pu] > rank[pv]){
                par[pv] = pu;
        }else if(rank[pv] > rank[pu]){
                par[pu] = pv; 
        }else{
                par[pu] = pv;
                rank[pv]++;
        }

        }

        public void unionBySize(int u, int v) {

        int pu = findUPar(u);
        int pv = findUPar(v);

        if(pu == pv){
            return;
        }
        
        if(size[pu] > size[pv]){
                par[pv] = pu;
                size[pu] += size[pv];
        }else if(size[pv] > size[pu]){
                par[pu] = pv;
                size[pv] += size[pu];
        }else{
                par[pu] = pv;
                size[pv] += size[pu];
        }

        

        }
    }
    

    static class Pair{
        int u;
        int v;
        int w;

        Pair(int u,int v,int w){
            this.u = u;
            this.v = v;
            this.w = w;
        }
    }

    class PairComparator implements Comparator<Pair>{

        public int compare(Pair p1,Pair p2){
            return p1.w - p2.w;
        }
    }

    public int spanningTree(int n, List<List<List<Integer>>> adj) {

        List<Pair> edgeLst = new ArrayList<>();

        for(int ind=0;ind<n;ind++){
            for(List<Integer> ele: adj.get(ind)){
                int v = ele.get(0);
                int w = ele.get(1);
                edgeLst.add(new Pair(ind,v,w));
            }
        }

        Collections.sort(edgeLst,new PairComparator());

        int sum = 0;

        DisjointSet disJoint = new DisjointSet(n);
        for(Pair pair : edgeLst){

            int w = pair.w;
            int u = pair.u;
            int v = pair.v;

            int pu = disJoint.findUPar(u);
            int pv = disJoint.findUPar(v);
            if(pu == pv){
                continue;
            }

            sum += w;
            disJoint.unionByRank(u,v);

        }

        return sum;
        
    }
}

