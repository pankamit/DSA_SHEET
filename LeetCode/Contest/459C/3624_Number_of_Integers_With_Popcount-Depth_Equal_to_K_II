## https://leetcode.com/problems/number-of-integers-with-popcount-depth-equal-to-k-ii/description/


class SegTree{
    HashMap<Integer,Integer>[] segArr;

    SegTree(int[] arr){
        int n = arr.length;
        segArr = new HashMap[4*n+1];
        build(arr,0,0,n-1);
        
    }

    void merge(int i,int i1,int i2){
        segArr[i] = new HashMap<>();
        
        for(Map.Entry<Integer,Integer> entry : segArr[i1].entrySet()){
            segArr[i].put(entry.getKey(),segArr[i].getOrDefault(entry.getKey(),0)+entry.getValue());    
        }

        for(Map.Entry<Integer,Integer> entry : segArr[i2].entrySet()){
            segArr[i].put(entry.getKey(),segArr[i].getOrDefault(entry.getKey(),0)+entry.getValue());
        }
    }

    void build(int[] arr,int i,int l,int r){
        if(l==r){
            if(segArr[i] == null){
                segArr[i] = new HashMap<>();
            }
            segArr[i].put(arr[l],1);
            return;
        }

        int mid = (l+r)/2;

        build(arr,2*i+1,l,mid);
        build(arr,2*i+2,mid+1,r);

        merge(i,2*i+1,2*i+2);

    }

    void update(int ind,int x,int i,int l,int r){

        if(l == r){
            //if(l == ind){
                segArr[i].clear();
                segArr[i].put(x,1);
            //}
            return;
        }

        int mid = (l+r)/2;
        if(ind <= mid && ind >= l){
            update(ind,x,2*i+1,l,mid);
        }else{
            update(ind,x,2*i+2,mid+1,r);
        }

        merge(i,2*i+1,2*i+2);
    }

    int search(int l1,int r1,int x,int i,int l,int r){

       
        if(r1<l || l1>r){
            // In no overlap
            return 0;
        }

        if(l1<=l && r1>=r){
            // complete overlap
            return segArr[i].getOrDefault(x,0);
        }

        int mid = (l+r)/2;

        int res1 = search(l1,r1,x,2*i+1,l,mid);
        int res2 = search(l1,r1,x,2*i+2,mid+1,r);

        int res = res1+res2;
        return res;
    }
}

class Solution {
    public int[] popcountDepth(long[] arr, long[][] qu) {
        int n = arr.length;
        int[] pArr = new int[n];

        for(int ind=0;ind<n;ind++){
            pArr[ind] = popCount(arr[ind]);
        }

        SegTree seg = new SegTree(pArr);
     
        List<Integer> lst = new ArrayList<>();
        for(int ind=0;ind<qu.length;ind++){
            if(qu[ind][0] == 1){
                int l = (int)qu[ind][1];
                int r = (int)qu[ind][2];
                int k = (int)qu[ind][3];
                lst.add(seg.search(l,r,k,0,0,n-1));
       
            }else{
                int inde = (int)qu[ind][1];
                long x = qu[ind][2];
                arr[inde] = x;
                pArr[inde] = popCount(x);
                seg.update(inde,pArr[inde],0,0,n-1);
            }
        }

        return lst.stream().mapToInt(Integer::intValue).toArray();


    }

    int popCount(long x){
        
        if(x == 1L){
            return 0;
        }
        x = Long.bitCount(x);
        return 1+popCount(x);
    }




}
